["import streamlit as st\nimport random\nimport time\n\n\ndef dummy_def_1():\n    response = random.choice(\n        [\n            \"Hello there! How can I assist you today?\",\n            \"Hi, human! Is there anything I can help you with?\",\n            \"Do you need help?\",\n        ]\n    )\n    for word in response.split():\n        yield word + \" \"\n        time.sleep(0.05)\n\n\nst.title(\"Simple chat\")\n\nif \"messages\" not in st.session_state:\n    st.session_state.messages = []\n\nfor message in st.session_state.messages:\n    with st.chat_message(message[\"role\"]):\n        st.markdown(message[\"content\"])\n\nif prompt := st.chat_input(\"What is up?\"):\n        st.session_state.messages.append({\"role\": \"user\", \"content\": prompt})\n        with st.chat_message(\"user\"):\n        st.markdown(prompt)\n\n        with st.chat_message(\"assistant\"):\n        response = st.write_stream(response_generator())\n        st.session_state.messages.append({\"role\": \"assistant\", \"content\": response})", "import pandas as pd\n\ndf = pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]})\ndf = df.reset_index()  \nfor index, row in df.iterrows():\n    print(row['c1'], row['c2'])", "\nimport openpyxl\nimport sys\n\nprint(\"This programme writes the data in any Comma-separated value file (such as: .csv or .data) to a Excel file.\")\nprint(\"The input and output files must be in the same directory of the python file for the programme to work.\\n\")\n\ncsv_name = input(\"Name of the CSV file for input (with the extension): \")\nsep = input(\"Separator of the CSV file: \")\nexcel_name = input(\"Name of the excel file for output (with the extension): \")\nsheet_name = input(\"Name of the excel sheet for output: \")\n\ntry:\n    wb = openpyxl.load_workbook(excel_name)\n    sheet = wb.get_sheet_by_name(sheet_name)\n\n    file = open(csv_name, \"r\", encoding=\"utf-8\")\nexcept:\n    print(\"File Error!\")\n    sys.exit()\n\nrow = 1\ncolumn = 1\n\nfor line in file:\n        line = line[:-1]\n    line = line.split(sep)\n\n        for data in line:\n                sheet.cell(row, column).value = data\n                column += 1\n\n        column = 1\n    row += 1\n\nwb.save(excel_name)\nfile.close()", "import hashlib\nimport os\nimport sys\nimport keyboard\n\n\ndef dummy_def_1(parent_folder):\n        \n    duplicate_img = {}\n    for dirName, subdirs, fileList in os.walk(parent_folder):\n                print('Scanning %s...' % dirName)\n        for filename in fileList:\n                        path = os.path.join(dirName, filename)\n                        file_hash = hash_file(path)\n                        if file_hash in duplicate_img:\n                duplicate_img[file_hash].append(path)\n            else:\n                duplicate_img[file_hash] = [path]\n    return duplicate_img\n\n\ndef dummy_def_2(duplicate_img):\n        for key in duplicate_img:\n        file_list = duplicate_img[key]\n        while len(file_list) > 1:\n            item = file_list.pop()\n            os.remove(item)\n\n\ndef dummy_def_3(dict1, dict2):\n    for key in dict2.keys():\n        if key in dict1:\n            dict1[key] = dict1[key] + dict2[key]\n        else:\n            dict1[key] = dict2[key]\n\n\ndef dummy_def_4(path, blocksize=65536):\n    img_file = open(path, 'rb')\n    hasher = hashlib.md5()\n    buf = img_file.read(blocksize)\n    while len(buf) > 0:\n        hasher.update(buf)\n        buf = img_file.read(blocksize)\n    img_file.close()\n        return hasher.hexdigest()\n\n\ndef dummy_def_5(dict1):\n    results = list(filter(lambda x: len(x) > 1, dict1.values()))\n    if len(results) > 0:\n        print('Found Duplicated Images - ')\n        print('Details -')\n        print('<--------------------->')\n        for result in results:\n                        for subresult in result:\n                print('\\t%s' % subresult)\n            print('<--------------------->')\n\n    else:\n        print('Unable to identify Similar Images')\n\n\nif __name__ == '__main__':\n    if len(sys.argv) > 1:\n        duplicate = {}\n        folders = sys.argv[1:]\n        for i in folders:\n                        if os.path.exists(i):\n                                join_dicts(duplicate, image_finder(i))\n            else:\n                print('%s is not a valid path, please verify' % i)\n                sys.exit()\n        print_results(duplicate)\n                        print(\n            \"Do you want to delete the Duplicate Images (If Any)? Press [y] for Yes.\"\n        )\n        while True:\n            if keyboard.read_key() == \"y\":\n                print(\"Deleting Duplicate Files\\n\")\n                delete_duplicate(duplicate)\n                print(\"Thank You\\n\")\n                break\n            else:\n                print(\"Nothing Deleted!!! Thank You\\n\")\n                break\n    else:\n        print(\"Use Command Line Interface\")\n        print(\"Hint: python file_finder.py <path of folders>\")\n        print(\"Please Read comments for greater detailing\")\n        ", "from speedtest import Speedtest\nimport tkinter as tk\nfrom tkinter import ttk\nfrom ttkthemes import ThemedStyle\n\nPRIMARY_COLOR = \"SECONDARY_COLOR = \"\nspeed = Speedtest()\n\n\ndef dummy_def_1():\n    print(\"Running speed test...\")\n\n    download_speed = speed.download()\n        download_speed = download_speed / 1024 / 1024\n    print(f\"Download Speed: {download_speed:.2f} Mbps\")\n    download_label.config(text=f\"Download Speed: {download_speed:.2f} Mbps\")\n\n    upload_speed = speed.upload()\n        upload_speed = upload_speed / 1024 / 1024\n    print(f\"Upload Speed: {upload_speed:.2f} Mbps\")\n    upload_label.config(text=f\"Upload Speed: {upload_speed:.2f} Mbps\")\n\n    ping_latency = speed.results.ping\n    print(f\"Ping latency: {ping_latency:.2f} ms\")\n    ping_label.config(text=f\"Latency: {ping_latency:.2f} ms\")\n\n    server = speed.get_best_server()\n    print(f\"Server: {server['sponsor']} ({server['name']})\")\n    server_label.config(text=f\"Server: {server['sponsor']} ({server['name']})\")\n\n\nwindow = tk.Tk()\nwindow.title(\"Internet Speed Test\")\nwindow.geometry(\"500x250\")\n\n\nstyle = ThemedStyle(window)\nstyle.theme_use('clam')\nstyle.configure(\"TLabel\", foreground=PRIMARY_COLOR, background=SECONDARY_COLOR)\nstyle.configure(\"TButton\", foreground=SECONDARY_COLOR,\n                background=PRIMARY_COLOR)\n\n\ndownload_label = ttk.Label(\n    window, text=\"Download Speed: \", font=(\"TkDefaultFont\", 15, \"bold\"))\ndownload_label.pack(pady=10)\n\nupload_label = ttk.Label(window, text=\"Upload Speed: \",\n                         font=(\"TkDefaultFont\", 15, \"bold\"))\nupload_label.pack(pady=10)\n\nping_label = ttk.Label(window, text=\"Latency: \",\n                       font=(\"TkDefaultFont\", 15, \"bold\"))\nping_label.pack(pady=10)\n\nserver_label = ttk.Label(window, text=\"Server: \",\n                         font=(\"TkDefaultFont\", 15, \"bold\"))\nserver_label.pack(pady=10)\n\nmeasure_button = tk.Button(window, text=\" Run Speed Test \", command=measure_internet_speed,\n                           fg=SECONDARY_COLOR, bg=PRIMARY_COLOR, font=(\"TkDefaultFont\", 12, \"bold\"))\nmeasure_button.pack(pady=10)\n\nwindow.mainloop()", "import sys\n\n\nclass Definations:\n    \n\n    def dummy_def_1(self, number):\n        self.number = number\n\n    def dummy_def_2(self):\n        return bin(int(self.number))[2:]\n\n    def dummy_def_3(self):\n        return int(str(self.number), 2)\n\n    def dummy_def_4(self):\n        return oct(int(self.number))[2:]\n\n    def dummy_def_5(self):\n        return int(str(self.number), 8)\n\n    def dummy_def_6(self):\n        return hex(self.number)[2:]\n\n    def dummy_def_7(self):\n        return int(str(self.number), 16)\n\n    def dummy_def_8(self):\n        num = int(str(self.number), 16)\n        return bin(num)[2:]\n\n    def dummy_def_9(self):\n        num = int(str(self.number), 16)\n        return oct(num)[2:]\n\n    def dummy_def_10(self):\n        num = int(str(self.number), 2)\n        return oct(num)[2:]\n\n    def dummy_def_11(self):\n        num = int(str(self.number), 2)\n        return hex(num)[2:]\n\n    def dummy_def_12(self):\n        num = int(str(self.number), 8)\n        return hex(num)[2:]\n\n    def dummy_def_13(self):\n        num = int(str(self.number), 8)\n        return bin(num)[2:]\n\n\nclass Converter(Definations):\n    \n\n    def dummy_def_14(self, number):\n        super().__init__(number)\n\n    def dummy_def_15(self, func_name):\n        return getattr(Definations, func_name)(self)\n\n    def dummy_def_16(self, FROM=\"d\", TO=\"b\"):\n        \n        bases = {'d': \"Decimal\", 'b': \"Binary\",\n                 'x': 'Hexadecimal', 'o': \"Octal\"}\n        to_call_function = bases[FROM] + '_to_' + bases[TO]\n        return f\"\\n{self.number} in {bases[FROM]} = {self.helper(to_call_function)} in {bases[TO]}\"\n\n\ndef dummy_def_17():\n    print()\n\n\ndef dummy_def_18():\n    print()\n\n\nif __name__ == '__main__':\n    header_decoration()\n    Num = Converter(input(\"Enter number = \"))\n    print(Num.convert(input(\"From = \"), input(\"To = \")))\n    footer_decoration()", "import re\n\n\ndef dummy_def_1(password):\n        if len(password) < 8:\n        return False\n\n        if not any(char.isupper() for char in password):\n        return False\n\n        if not any(char.islower() for char in password):\n        return False\n\n        if not any(char.isdigit() for char in password):\n        return False\n\n        special_chars = re.compile('[@_!    if not special_chars.search(password):\n        return False\n\n    return True\n\n\ndef dummy_def_2():\n    password = input(\"Enter your password: \")\n\n    if is_strong_password(password):\n        print(\"Strong password! Good job.\")\n    else:\n        print(\"Weak password. Please make it stronger.\")\n\n\nif __name__ == \"__main__\":\n    main()", "import pyperclip\nnormal_word = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n               \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\nmorse_code = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\",\n              \"-----\", \".----\", \"..---\", \"...--\", \"....-\", \".....\", \"-....\", \"--...\", \"---..\", \"----.\"]\n\n\ndef dummy_def_1():\n    option = int(input(\"Choose 1.For Encoding and 2.For Decoding:\"))\n    if (option == 1):\n        word = input(\"Enter the sentence that you want to encode:\").upper()\n        coded_form = \"\"\n        for letter in word:\n            if letter == \" \":\n                coded_form += \"/ \"\n            else:\n                ind = normal_word.index(letter)\n                coded_form += morse_code[ind]\n                coded_form += \" \"\n        print(f\"{word} in morse code is {coded_form}\")\n        pyperclip.copy(coded_form)\n        print(\"Copied it to clipboard \ud83d\ude09\")\n        print(\"\\n\")\n        option_menu()\n\n    if (option == 2):\n        decoded_form = \"\"\n        encode_word = input(\"Enter the sentence that you want to decode:\")\n        encoded_word = encode_word.split(\" \")\n        for item in encoded_word:\n            if item.isalnum() or item.isalpha():\n                print(\"Please enter valid morse code \ud83d\ude00\")\n                option_menu()\n            if item == \"/\":\n                decoded_form += \" \"\n                continue\n            if item == \"\":\n                continue\n            else:\n                ind = morse_code.index(item)\n                decoded_form += normal_word[ind]\n        print(f\"{encode_word} in decoded form is {decoded_form}\")\n        pyperclip.copy(decoded_form)\n        print(\"Copied it to clipboard \ud83d\ude09\")\n        print(\"\\n\")\n        option_menu()\n\n\noption_menu()", "class Solution:\n    def dummy_def_1(self, nums1: List[int], nums2: List[int]) -> float:\n        merged = []\n        i, j = 0, 0\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n                \n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n            \n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        mid = len(merged) // 2\n        if len(merged) % 2 == 0:\n            return (merged[mid-1] + merged[mid]) / 2\n        else:\n            return merged[mid]", "class Solution:\n    ans = 0\n    def dummy_def_1(self, i, j, grid: List[List[int]], curLen, pLen)->None:\n        if(grid[i][j]==2):\n            if(pLen-1==curLen):\n                self.ans+=1\n            return\n        elif (grid[i][j]==-1):\n            return\n        curLen+=1\n        grid[i][j]=-1\n        if(i-1>=0):\n            self.findPathNum(i-1, j, grid, curLen, pLen)\n        if(j-1>=0):\n            self.findPathNum(i, j-1, grid, curLen, pLen)\n        if(i+1<len(grid)):\n            self.findPathNum(i+1, j, grid, curLen, pLen)\n        if(j+1<len(grid[0])):\n            self.findPathNum(i, j+1, grid, curLen, pLen)\n        grid[i][j]=0\n        \n            \n    def dummy_def_2(self, grid: List[List[int]]) -> int:\n        pathLen = 0\n        start = (0, 0)\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if(grid[i][j]!=-1):\n                    pathLen+=1\n                    if(grid[i][j]==1):\n                        start = (i, j)\n        self.findPathNum(start[0], start[1], grid, 0, pathLen)\n        return self.ans", "from heapq import heappush, heappop\nfrom typing import List\n\nclass Solution:\n    def dummy_def_1(self, grid: List[List[int]]) -> int:\n        src, dst = grid[0][0], grid[len(grid)-1][len(grid)-1]\n        visited = set()\n        heap_queue = [(src, 0, 0)]          output = 0\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n        while heap_queue:\n            current, row, col = heappop(heap_queue)\n            output = max(current, output)\n\n                        if current == dst:\n                break\n\n            for x, y in directions:\n                dx, dy = row+x, col+y\n                if self.check_bounds(dx, dy, grid) and (dx, dy) not in visited:\n                    heappush(heap_queue, (grid[dx][dy], dx, dy))\n                    visited.add((dx, dy))\n        return output\n\n    def dummy_def_2(self, r, c, grid) -> bool:\n        if 0 <= r < len(grid[0]) and 0 <= c < len(grid):\n            return True\n        return False\n\n\nif __name__ == \"__main__\":\n    grid = [[0, 2], [1, 3]]\n    print(Solution().swimInWater(grid))", "def dummy_def_1(self, A):\n    res = inc = dec = 1\n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            inc = dec + 1\n            dec = 1\n        elif A[i] < A[i - 1]:\n            dec = inc + 1\n            inc = 1\n        else:\n            inc = 1\n            dec = 1\n        res = max(res, max(inc, dec))\n    return res", "def dummy_def_1(self, root, voyage):\n    res = []\n    self.i = 0\n    def dummy_def_2(root):\n        if not root: return True\n        if root.val != voyage[self.i]: return False\n        self.i += 1\n        if root.left and root.left.val != voyage[self.i]:\n            res.append(root.val)\n            root.left, root.right = root.right, root.left\n        return dfs(root.left) and dfs(root.right)\n    return res if dfs(root) else [-1]", "\n\ndef dummy_def_1(self, A):\n    res = []\n    n = len(A)\n    while A:\n        smallest = A.index(min(A))\n        res.append(smallest + 1)\n        res.append(len(A))\n        A = list(reversed(A[:smallest + 1])) + A[smallest + 1:]\n        A.reverse()\n        del A[-1]\n    res.append(n)\n    return res", "def dummy_def_1(self, root):\n    stack = [[(root, 0)]]\n    layer = 0\n    while True:\n        children = []\n        for node, value in stack[-1]:\n            if node.left: children.append((node.left, 2 * value))\n            if node.right: children.append((node.right, 2 * value + 1))\n            if node.right and not node.left: return False\n        if not children: break\n        if len(stack[-1]) != pow(2, layer): return False\n        stack.append(children)\n        layer += 1\n    return len(stack[-1]) == stack[-1][-1][1] + 1", "\ndef dummy_def_1(self, root1, root2):\n    if not root1 or not root2:\n        return root1 == root2\n    if root1.val != root2.val:\n        return False\n    return self.flipEquiv(root1.left, root2.left) and \\\n            self.flipEquiv(root1.right, root2.right) or \\\n            self.flipEquiv(root1.left, root2.right) and \\\n            self.flipEquiv(root1.right, root2.left)\n\n\ndef dummy_def_2(self, root1, root2):\n    def dummy_def_3(root):\n        if root:\n            if root.left and root.right and root.left.val > root.right.val:\n                root.left, root.right = root.right, root.left\n            if not root.left:\n                root.left, root.right = root.right, root.left\n            flip(root.left)\n            flip(root.right)\n    \n    def dummy_def_4(root1, root2):\n        if not root1 or not root2:\n            return root1 == root2\n        return root1.val == root2.val and \\\n                is_equal(root1.left, root2.left) and \\\n                is_equal(root1.right, root2.right)\n    \n    flip(root1)\n    flip(root2)\n    return is_equal(root1, root2)", "def dummy_def_1(self, deck):\n    deck.sort()\n    res = [0] * len(deck)\n    index = list(range(len(deck)))\n    \n    for i in range(len(deck)):\n        res[index.pop(0)] = deck[i]\n        if index: index.append(index.pop(0))\n    return res", "\n\ndef dummy_def_1(self, edges):\n    id = list(range(len(edges) + 1))\n    \n    def dummy_def_2(u):\n        root = u\n        while root != id[root]: root = id[root]\n        \n                while u != root:\n            next = id[u]\n            id[u] = root\n            u = next\n        \n        return root\n    \n    for u, v in edges:\n        root1, root2 = find(u), find(v)\n        if root1 == root2: return [u, v]\n        \n                id[root1] = root2", "def dummy_def_1(self, root):\n    if not root: return 0\n    stack = [[(root, 0)]]\n    res = 1\n    while True:\n        children = []\n        for node, value in stack[-1]:\n            if node.left: children.append((node.left, value * 2))\n            if node.right: children.append((node.right, value * 2 + 1))\n        if not children: break\n        stack.append(children)\n        res = max(res, children[-1][1] - children[0][1] + 1)\n    return res", "\ndef dummy_def_1(self, root):\n    def dummy_def_2(root):\n        if not root: return 0\n        return 1 + max(get_height(root.left), get_height(root.right))\n    \n    def dummy_def_3(res, node, row, left, right):\n        if not node: return\n        mid = (left + right) // 2\n        res[row][mid] = str(node.val)\n        update(res, node.left, row + 1, left, mid - 1)\n        update(res, node.right, row + 1, mid + 1, right)\n    \n    height = get_height(root)\n    width = 2 ** height - 1\n    res = [['' for _ in range(width)] for _ in range(height)]\n    update(res, root, 0, 0, width - 1)\n    return res", "def dummy_def_1(self, root):\n    nodes = collections.defaultdict(list)\n    \n    def dummy_def_2(root):\n        if not root: return 'None'\n        struct = '%s,%s,%s' % (str(root.val), helper(root.left), helper(root.right))\n        nodes[struct].append(root)\n        return struct\n    \n    helper(root)\n    return [nodes[struct][0] for struct in nodes if len(nodes[struct]) > 1]", "\ndef dummy_def_1(self, root, v, d):\n    dummy, dummy.left = TreeNode(v), root\n    row = [dummy]\n    for _ in range(d - 1):\n        row = [kid for node in row for kid in (node.left, node.right) if kid]\n    \n    for node in row:\n        node.left, node.left.left = TreeNode(v), node.left\n        node.right, node.right.right = TreeNode(v), node.right\n    return dummy.left", "def dummy_def_1(self, root, key):\n    if not root: return None\n    if key < root.val: \n        root.left = self.deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = self.deleteNode(root.right, key)\n    else:\n                if not root.left:\n            temp = root.right\n            root = None\n            return temp\n        elif not root.right:\n            temp = root.left\n            root = None\n            return temp\n        \n                curr = root.right\n        while curr.left:\n            curr = curr.left\n        \n        root.val = curr.val\n        root.right = self.deleteNode(root.right, curr.val)\n    return root", "class Codec:\n\n    def dummy_def_1(self, root):\n        preorder = []\n        \n        def dummy_def_2(node):\n            if node:\n                preorder.append(node.val)\n                helper(node.left)\n                helper(node.right)\n        helper(root)\n        return ' '.join(map(str, preorder))\n        \n\n    def dummy_def_3(self, data):\n        vals = collections.deque(int(val) for val in data.split())\n        \n        def dummy_def_4(minval, maxval):\n            if vals and minval < vals[0] < maxval:\n                val = vals.popleft()\n                node = TreeNode(val)\n                node.left = build(minval, val)\n                node.right = build(val, maxval)\n                return node\n\n        return build(float('-infinity'), float('infinity'))", "def dummy_def_1(self, root, target):\n    self.result = 0\n    cache = {0:1}\n    \n    def dummy_def_2(root, currPathSum):\n        if not root: return  \n\n        currPathSum += root.val\n        oldPathSum = currPathSum - target\n\n        self.result += cache.get(oldPathSum, 0)\n        cache[currPathSum] = cache.get(currPathSum, 0) + 1\n\n\n        dfs(root.left, currPathSum)\n        dfs(root.right, currPathSum)\n\n        cache[currPathSum] -= 1\n    \n    dfs(root, 0)\n    return self.result", "\ndef dummy_def_1(self, root):\n        lookup = {}\n        def dummy_def_2(root):\n            if not root: return 0\n            if root in lookup: return lookup[root]\n            val = 0\n        \n            if root.left:\n                val += helper(root.left.left) + helper(root.left.right)\n            if root.right:\n                val += helper(root.right.left) + helper(root.right.right)\n            val = max(val + root.val, helper(root.left) + helper(root.right))\n            lookup[root] = val\n            return val\n        return helper(root)\n\ndef dummy_def_3(self, root):\n    def dummy_def_4(root):\n        if not root: return [0, 0]\n        left, right = helper(root.left), helper(root.right)\n        not_robbed = max(left) + max(right)\n        robbed = root.val + left[0] + right[0]\n        return [not_robbed, robbed]\n    return max(helper(root))", "def dummy_def_1(self, nums):\n    if len(nums) <= 1: return -1\n    slow, fast = nums[0], nums[nums[0]]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n    \n    fast = 0\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    return slow", "def dummy_def_1(self, input):\n    return [a + b if c == '+' else a - b if c == '-' else a * b \\\n            for i, c in enumerate(input) if c in '+-*' \\\n            for a in self.diffWaysToCompute(input[:i]) \\\n            for b in self.diffWaysToCompute(input[i+1:])] or [int(input)]", "def dummy_def_1(self, matrix, target):\n    def dummy_def_2(low, high, row):\n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[row][mid] < target: low = mid + 1\n            elif matrix[row][mid] > target: high = mid - 1\n            else: return True\n        return False\n    \n    if not matrix or not matrix[0]: return False\n    for i in range(len(matrix)):\n        if matrix[i][0] > target: return False\n        elif matrix[i][0] == target: return True\n        if helper(0, len(matrix[i]) - 1, i): return True\n    return False\n\ndef dummy_def_3(self, matrix, target):\n    if not matrix or not matrix[0]: return False\n    row, col = 0, len(matrix[0]) - 1\n    while row < len(matrix) and col >= 0:\n        if matrix[row][col] > target: col -= 1\n        elif matrix[row][col] < target: row += 1\n        else: return True\n    return False", "def dummy_def_1(self, root, p, q):\n    if root in (None, p, q): return root\n    left = self.lowestCommonAncestor(root.left, p, q)\n    right = self.lowestCommonAncestor(root.right, p, q)\n    return root if left and right else left or right", "def dummy_def_1(self, root, k):\n    inorder = []\n    def dummy_def_2(root):\n        if root:\n            helper(root.left)\n            inorder.append(root.val)\n            helper(root.right)\n    \n    helper(root)\n    return inorder[k-1]\n\ndef dummy_def_3(self, root, k):\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if k == 0: return root.val\n        root = root.right", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, nums: List[int], k: int) -> List[int]:\n\u00a0 \u00a0 \u00a0 \u00a0 count = {}\n\u00a0 \u00a0 \u00a0 \u00a0 freq = [[] for i in range(len(nums)+1)]\n\u00a0 \u00a0 \u00a0 \u00a0 for i in nums: \n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 count[i] = 1 + count.get(i,0)\n\u00a0 \u00a0 \u00a0 \u00a0 for key,value in count.items(): \n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 freq[value].append(key) \n\u00a0 \u00a0 \u00a0 \u00a0 result = []\n\u00a0 \u00a0 \u00a0 \u00a0 for i in range(len(freq)-1,-1,-1): \n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for j in freq[i]: \n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 result.append(j)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if len(result)==k:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return result\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, nums: List[int]) -> List[int]:\n\u00a0 \u00a0 \u00a0 \u00a0 result = [1] * len(nums)\n\u00a0 \u00a0 \u00a0 \u00a0 prefix = postfix = 1\n\u00a0 \u00a0 \u00a0 \u00a0 for i in range(len(nums)):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 result[i] = prefix\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 prefix *= nums[i]\n\u00a0 \u00a0 \u00a0 \u00a0 for i in range(len(nums)-1, -1, -1):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 result[i] *= postfix\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 postfix *= nums[i]\n\u00a0 \u00a0 \u00a0 \u00a0 return result", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, matrix: List[List[int]]) -> List[int]:\n\u00a0 \u00a0 \u00a0 \u00a0 res = []\n\u00a0 \u00a0 \u00a0 \u00a0 left, right = 0, len(matrix[0])\n\u00a0 \u00a0 \u00a0 \u00a0 top, bottom = 0, len(matrix)\n\u00a0 \u00a0 \u00a0 \u00a0 while left < right and top < bottom:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for i in range(left, right):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 res.append(matrix[top][i])\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 top += 1\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for i in range(top, bottom):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 res.append(matrix[i][right-1])\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 right -= 1\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if not(left < right and top < bottom):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for i in range(right-1, left-1, -1):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 res.append(matrix[bottom-1][i])\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bottom -= 1\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for i in range(bottom-1, top-1, -1):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 res.append(matrix[i][left])\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 left += 1\n\u00a0 \u00a0 \u00a0 \u00a0 return res", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, nums: List[int]) -> int:\n\u00a0 \u00a0 \u00a0 \u00a0 dp = [1] * len(nums) \u00a0 \u00a0 \u00a0 \u00a0 for i in range(len(nums)-1, -1, -1): \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for j in range(i+1, len(nums)):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if nums[j] > nums[i]:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dp[i] = max(dp[i], 1 + dp[j])\n\u00a0 \u00a0 \u00a0 \u00a0 return max(dp)", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n\u00a0 \u00a0 \u00a0 \u00a0 dummy = ListNode(0,head)\n\u00a0 \u00a0 \u00a0 \u00a0 leftPrev, curr = dummy, head\n\u00a0 \u00a0 \u00a0 \u00a0 for i in range(left-1): leftPrev,curr = curr, curr.next\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 prev = None\n\u00a0 \u00a0 \u00a0 \u00a0 for i in range(right-left+1):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 temp = curr.next\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 curr.next = prev\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 prev, curr = curr,temp\n\u00a0 \u00a0 \u00a0 \u00a0 leftPrev.next.next = curr\n\u00a0 \u00a0 \u00a0 \u00a0 leftPrev.next = prev\n\u00a0 \u00a0 \u00a0 \u00a0 return dummy.next", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, s: str, k: int) -> int:\n\u00a0 \u00a0 \u00a0 \u00a0 count = {}\n\u00a0 \u00a0 \u00a0 \u00a0 l = 0\n\u00a0 \u00a0 \u00a0 \u00a0 result = 0\n\u00a0 \u00a0 \u00a0 \u00a0 for r in range(len(s)):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 count[s[r]] = 1 + count.get(s[r], 0)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if ((r-l+1) - max(count.values())) > k: \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 count[s[l]] -= 1\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 l += 1\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 result = max(result, r-l+1)\n\u00a0 \u00a0 \u00a0 \u00a0 return result", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, nums: List[int]) -> bool:\n\u00a0 \u00a0 \u00a0 \u00a0 first = second = float('inf')\n\u00a0 \u00a0 \u00a0 \u00a0 for num in nums: \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if num <= first: first = num \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 elif num <= second: second = num \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else: return True\n\u00a0 \u00a0 \u00a0 \u00a0 return False", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, nums: List[int]) -> int:\n\u00a0 \u00a0 \u00a0 \u00a0 g_max, g_min = nums[0], nums[0]\n\u00a0 \u00a0 \u00a0 \u00a0 c_max, c_min = 0, 0\n\u00a0 \u00a0 \u00a0 \u00a0 total = 0\n\u00a0 \u00a0 \u00a0 \u00a0 for i in nums:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 total += i\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c_max = max(i, i + c_max)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 g_max = max(g_max, c_max)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c_min = min(i, i + c_min)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 g_min = min(g_min, c_min)\n\u00a0 \u00a0 \u00a0 \u00a0 return max(g_max, total-g_min) if g_max > 0 else g_max", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, nums: List[int]) -> int:\n\u00a0 \u00a0 \u00a0 \u00a0 l = res = 0\n\u00a0 \u00a0 \u00a0 \u00a0 k = 1\n\u00a0 \u00a0 \u00a0 \u00a0 for r in range(len(nums)):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (nums[r]==0): k-=1\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (k<0):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if nums[l] == 0: k += 1\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 l += 1\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 res = max(res,r-l)\n\u00a0 \u00a0 \u00a0 \u00a0 return res", "class Solution:\n\u00a0 \u00a0 def dummy_def_1(self, nums: List[int]) -> int:\n\u00a0 \u00a0 \u00a0 \u00a0 maxSum = nums[0]\n\u00a0 \u00a0 \u00a0 \u00a0 curr_sum = 0\n\u00a0 \u00a0 \u00a0 \u00a0 for i in nums:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if curr_sum < 0: curr_sum = 0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 curr_sum += i\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 maxSum = max(maxSum,curr_sum)\n\u00a0 \u00a0 \u00a0 \u00a0 return maxSum", "class Solution:\n    def dummy_def_1(self, strs: List[str]) -> List[List[str]]:\n        ans = defaultdict(list)\n\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord(\"a\")] += 1\n            ans[tuple(count)].append(s)\n        return ans.values()\n", "class Solution:\n    def dummy_def_1(self, nums: List[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n\n        for n in numSet:\n            if (n - 1) not in numSet:\n                length = 1\n                while (n + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest\n", "class Solution:\n    \n    def dummy_def_1(self, strs: List[str]) -> str:\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"        return res\n\n    def dummy_def_2(self, s: str) -> List[str]:\n        res = []\n        i = 0\n        \n        while i < len(s):\n            j = i\n            while s[j] != '                j += 1\n            length = int(s[i:j])\n            i = j + 1\n            j = i + length\n            res.append(s[i:j])\n            i = j\n            \n        return res\n", "class Solution:\n    def dummy_def_1(self, board: List[List[str]]) -> bool:\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        squares = defaultdict(set)  \n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                if (\n                    board[r][c] in rows[r]\n                    or board[r][c] in cols[c]\n                    or board[r][c] in squares[(r // 3, c // 3)]\n                ):\n                    return False\n                cols[c].add(board[r][c])\n                rows[r].add(board[r][c])\n                squares[(r // 3, c // 3)].add(board[r][c])\n\n        return True\n", "class Solution:\n    def dummy_def_1(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        for i, a in enumerate(nums):\n            if a > 0:\n                break\n\n            if i > 0 and a == nums[i - 1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([a, nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n                        \n        return res\n", "class Solution:\n    def dummy_def_1(self, numbers: List[int], target: int) -> List[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l < r:\n            curSum = numbers[l] + numbers[r]\n\n            if curSum > target:\n                r -= 1\n            elif curSum < target:\n                l += 1\n            else:\n                return [l + 1, r + 1]\n", "class Solution:\n    def dummy_def_1(self, heights: List[int]) -> int:\n        l, r = 0, len(heights) - 1\n        res = 0\n\n        while l < r:\n            res = max(res, min(heights[l], heights[r]) * (r - l))\n            if heights[l] < heights[r]:\n                l += 1\n            elif heights[r] <= heights[l]:\n                r -= 1\n            \n        return res\n", "class Solution:\n    def dummy_def_1(self, s1: str, s2: str) -> bool:\n        if len(s1) > len(s2):\n            return False\n\n        s1Count, s2Count = [0] * 26, [0] * 26\n        for i in range(len(s1)):\n            s1Count[ord(s1[i]) - ord(\"a\")] += 1\n            s2Count[ord(s2[i]) - ord(\"a\")] += 1\n\n        matches = 0\n        for i in range(26):\n            matches += 1 if s1Count[i] == s2Count[i] else 0\n\n        l = 0\n        for r in range(len(s1), len(s2)):\n            if matches == 26:\n                return True\n\n            index = ord(s2[r]) - ord(\"a\")\n            s2Count[index] += 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] + 1 == s2Count[index]:\n                matches -= 1\n\n            index = ord(s2[l]) - ord(\"a\")\n            s2Count[index] -= 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] - 1 == s2Count[index]:\n                matches -= 1\n            l += 1\n        return matches == 26\n", "class Solution:\n    def dummy_def_1(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        intervals.sort()\n        minHeap = []\n        res = {}\n        i = 0\n        for q in sorted(queries):\n            while i < len(intervals) and intervals[i][0] <= q:\n                l, r = intervals[i]\n                heapq.heappush(minHeap, (r - l + 1, r))\n                i += 1\n\n            while minHeap and minHeap[0][1] < q:\n                heapq.heappop(minHeap)\n            res[q] = minHeap[0][0] if minHeap else -1\n        return [res[q] for q in queries]\n", "class Solution:\n    def dummy_def_1(self, height: List[int]) -> int:\n        if not height:\n            return 0\n\n        l, r = 0, len(height) - 1\n        leftMax, rightMax = height[l], height[r]\n        res = 0\n        while l < r:\n            if leftMax < rightMax:\n                l += 1\n                leftMax = max(leftMax, height[l])\n                res += leftMax - height[l]\n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])\n                res += rightMax - height[r]\n        return res\n", "class Solution:\n    def dummy_def_1(self, heights: List[int]) -> int:\n        maxArea = 0\n        stack = []  \n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i - index))\n                start = index\n            stack.append((start, h))\n\n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights) - i))\n        return maxArea\n", "class Solution:\n    def dummy_def_1(self, nums1: List[int], nums2: List[int]) -> float:\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n\n        if len(B) < len(A):\n            A, B = B, A\n\n        l, r = 0, len(A) - 1\n        while True:\n            i = (l + r) // 2\n            j = half - i - 2\n\n            Aleft = A[i] if i >= 0 else float(\"-infinity\")\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft > Bright:\n                r = i - 1\n            else:\n                l = i + 1\n", "\nclass Solution:\n    \n    def dummy_def_1(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists or len(lists) == 0:\n            return None\n\n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if (i + 1) < len(lists) else None\n                mergedLists.append(self.mergeList(l1, l2))\n            lists = mergedLists\n        return lists[0]\n\n    def dummy_def_2(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next\n", "class Solution:\n    def dummy_def_1(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        groupPrev = dummy\n\n        while True:\n            kth = self.getKth(groupPrev, k)\n            if not kth:\n                break\n            groupNext = kth.next\n\n            prev, curr = kth.next, groupPrev.next\n            while curr != groupNext:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            tmp = groupPrev.next\n            groupPrev.next = kth\n            groupPrev = tmp\n        return dummy.next\n\n    def dummy_def_2(self, curr, k):\n        while curr and k > 0:\n            curr = curr.next\n            k -= 1\n        return curr\n", "\n\nclass Solution:\n    def dummy_def_1(self, root: Optional[TreeNode]) -> int:\n        res = [root.val]\n\n        def dummy_def_2(root):\n            if not root:\n                return 0\n\n            leftMax = dfs(root.left)\n            rightMax = dfs(root.right)\n            leftMax = max(leftMax, 0)\n            rightMax = max(rightMax, 0)\n\n            res[0] = max(res[0], root.val + leftMax + rightMax)\n            return root.val + max(leftMax, rightMax)\n\n        dfs(root)\n        return res[0]\n", "\nclass Codec:\n    \n        def dummy_def_1(self, root: Optional[TreeNode]) -> str:\n        res = []\n\n        def dummy_def_2(node):\n            if not node:\n                res.append(\"N\")\n                return\n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return \",\".join(res)\n        \n        def dummy_def_3(self, data: str) -> Optional[TreeNode]:\n        vals = data.split(\",\")\n        self.i = 0\n\n        def dummy_def_4():\n            if vals[self.i] == \"N\":\n                self.i += 1\n                return None\n            node = TreeNode(int(vals[self.i]))\n            self.i += 1\n            node.left = dfs()\n            node.right = dfs()\n            return node\n\n        return dfs()\n", "class Solution:\n    def dummy_def_1(self, n: int) -> List[List[str]]:\n        col = set()\n        posDiag = set()\n        negDiag = set()\n\n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def dummy_def_2(r):\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n\n            for c in range(n):\n                if c in col or (r + c) in posDiag or (r - c) in negDiag:\n                    continue\n\n                col.add(c)\n                posDiag.add(r + c)\n                negDiag.add(r - c)\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col.remove(c)\n                posDiag.remove(r + c)\n                negDiag.remove(r - c)\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res\n", "class TrieNode:\n    def dummy_def_1(self):\n        self.children = {}\n        self.isWord = False\n        self.refs = 0\n\n    def dummy_def_2(self, word):\n        cur = self\n        cur.refs += 1\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n            cur.refs += 1\n        cur.isWord = True\n\n    def dummy_def_3(self, word):\n        cur = self\n        cur.refs -= 1\n        for c in word:\n            if c in cur.children:\n                cur = cur.children[c]\n                cur.refs -= 1\n\nclass Solution:\n    def dummy_def_4(self, board: List[List[str]], words: List[str]) -> List[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n\n        ROWS, COLS = len(board), len(board[0])\n        res, visit = set(), set()\n\n        def dummy_def_5(r, c, node, word):\n            if (\n                r not in range(ROWS) \n                or c not in range(COLS)\n                or board[r][c] not in node.children\n                or node.children[board[r][c]].refs < 1\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            node = node.children[board[r][c]]\n            word += board[r][c]\n            if node.isWord:\n                node.isWord = False\n                res.add(word)\n                root.removeWord(word)\n\n            dfs(r + 1, c, node, word)\n            dfs(r - 1, c, node, word)\n            dfs(r, c + 1, node, word)\n            dfs(r, c - 1, node, word)\n            visit.remove((r, c))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, root, \"\")\n\n        return list(res)\n", "class Solution:\n    def dummy_def_1(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n\n        nei = collections.defaultdict(list)\n        wordList.append(beginWord)\n        for word in wordList:\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                nei[pattern].append(word)\n\n        visit = set([beginWord])\n        q = deque([beginWord])\n        res = 1\n        while q:\n            for i in range(len(q)):\n                word = q.popleft()\n                if word == endWord:\n                    return res\n                for j in range(len(word)):\n                    pattern = word[:j] + \"*\" + word[j + 1 :]\n                    for neiWord in nei[pattern]:\n                        if neiWord not in visit:\n                            visit.add(neiWord)\n                            q.append(neiWord)\n            res += 1\n        return 0\n", "class Solution:\n    def dummy_def_1(self, tickets: List[List[str]]) -> List[str]:\n        adj = {src: [] for src, dst in tickets}\n        res = []\n\n        for src, dst in tickets:\n            adj[src].append(dst)\n\n        for key in adj:\n            adj[key].sort()\n\n        def dummy_def_2(adj, result, src):\n            if src in adj:\n                destinations = adj[src][:]\n                while destinations:\n                    dest = destinations[0]\n                    adj[src].pop(0)\n                    dfs(adj, res, dest)\n                    destinations = adj[src][:]\n            res.append(src)\n\n        dfs(adj, res, \"JFK\")\n        res.reverse()\n\n        if len(res) != len(tickets) + 1:\n            return []\n\n        return res\n", "class MinStack:\n    def dummy_def_1(self):\n        self.stack = []\n        self.minStack = []\n\n    def dummy_def_2(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def dummy_def_3(self) -> None:\n        self.stack.pop()\n        self.minStack.pop()\n\n    def dummy_def_4(self) -> int:\n        return self.stack[-1]\n\n    def dummy_def_5(self) -> int:\n        return self.minStack[-1]\n", "class Solution:\n    def dummy_def_1(self, tokens: List[str]) -> int:\n        stack = []\n        for c in tokens:\n            if c == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif c == \"-\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif c == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif c == \"/\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(float(b) / a))\n            else:\n                stack.append(int(c))\n        return stack[0]\n", "class Solution:\n    def dummy_def_1(self, n: int) -> List[str]:\n        stack = []\n        res = []\n\n        def dummy_def_2(openN, closedN):\n            if openN == closedN == n:\n                res.append(\"\".join(stack))\n                return\n\n            if openN < n:\n                stack.append(\"(\")\n                backtrack(openN + 1, closedN)\n                stack.pop()\n            if closedN < openN:\n                stack.append(\")\")\n                backtrack(openN, closedN + 1)\n                stack.pop()\n\n        backtrack(0, 0)\n        return res\n", "class Solution:\n    def dummy_def_1(self, target: int, position: List[int], speed: List[int]) -> int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n        stack = []\n        for p, s in pair:              stack.append((target - p) / s)\n            if len(stack) >= 2 and stack[-1] <= stack[-2]:\n                stack.pop()\n        return len(stack)\n", "class Solution:\n    def dummy_def_1(self, temperatures: List[int]) -> List[int]:\n        res = [0] * len(temperatures)\n        stack = []  \n        for i, t in enumerate(temperatures):\n            while stack and t > stack[-1][0]:\n                stackT, stackInd = stack.pop()\n                res[stackInd] = i - stackInd\n            stack.append((t, i))\n        return res\n", "class Solution:\n    def dummy_def_1(self, matrix: List[List[int]], target: int) -> bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n\n        top, bot = 0, ROWS - 1\n        while top <= bot:\n            row = (top + bot) // 2\n            if target > matrix[row][-1]:\n                top = row + 1\n            elif target < matrix[row][0]:\n                bot = row - 1\n            else:\n                break\n\n        if not (top <= bot):\n            return False\n        row = (top + bot) // 2\n        l, r = 0, COLS - 1\n        while l <= r:\n            m = (l + r) // 2\n            if target > matrix[row][m]:\n                l = m + 1\n            elif target < matrix[row][m]:\n                r = m - 1\n            else:\n                return True\n        return False\n", "class Solution:\n    def dummy_def_1(self, piles: List[int], h: int) -> int:\n        l, r = 1, max(piles)\n        res = r\n\n        while l <= r:\n            k = (l + r) // 2\n\n            totalTime = 0\n            for p in piles:\n                totalTime += math.ceil(float(p) / k)\n            if totalTime <= h:\n                res = k\n                r = k - 1\n            else:\n                l = k + 1\n        return res\n", "\nclass Solution:\n    def dummy_def_2(self, root: Optional[TreeNode]) -> List[List[int]]:\n        res = []\n        q = deque()\n        if root:\n            q.append(root)\n\n        while q:\n            val = []\n\n            for i in range(len(q)):\n                node = q.popleft()\n                val.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(val)\n        return res\n", "\nclass Solution:\n    def dummy_def_2(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        q = deque([root])\n\n        while q:\n            rightSide = None\n            qLen = len(q)\n\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    rightSide = node\n                    q.append(node.left)\n                    q.append(node.right)\n            if rightSide:\n                res.append(rightSide.val)\n        return res\n", "\nclass Solution:\n    def dummy_def_2(self, root: Optional[TreeNode]) -> bool:\n        def dummy_def_3(node, left, right):\n            if not node:\n                return True\n            if not (left < node.val < right):\n                return False\n\n            return valid(node.left, left, node.val) and valid(\n                node.right, node.val, right\n            )\n\n        return valid(root, float(\"-inf\"), float(\"inf\"))\n", "\nclass Solution:\n    def dummy_def_2(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        curr = root\n\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            k -= 1\n            if k == 0:\n                return curr.val\n            curr = curr.right\n", "\nclass Solution:\n    def dummy_def_2(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])\n        return root\n", "class Solution:\n    def dummy_def_1(self, grid: List[List[str]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n\n        islands = 0\n        visit = set()\n        rows, cols = len(grid), len(grid[0])\n\n        def dummy_def_2(r, c):\n            if (\n                r not in range(rows)\n                or c not in range(cols)\n                or grid[r][c] == \"0\"\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n            for dr, dc in directions:\n                dfs(r + dr, c + dc)\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == \"1\" and (r, c) not in visit:\n                    islands += 1\n                    dfs(r, c)\n        return islands\n", "class Solution:\n    def dummy_def_1(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n\n        def dummy_def_2(r, c):\n            if (\n                r < 0\n                or r == ROWS\n                or c < 0\n                or c == COLS\n                or grid[r][c] == 0\n                or (r, c) in visit\n            ):\n                return 0\n            visit.add((r, c))\n            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n\n        area = 0\n        for r in range(ROWS):\n            for c in range(COLS):\n                area = max(area, dfs(r, c))\n        return area\n", "\n\nclass Solution:\n    def dummy_def_2(self, node: Optional['Node']) -> Optional['Node']:\n        oldToNew = {}\n\n        def dummy_def_3(node):\n            if node in oldToNew:\n                return oldToNew[node]\n\n            copy = Node(node.val)\n            oldToNew[node] = copy\n            for nei in node.neighbors:\n                copy.neighbors.append(dfs(nei))\n            return copy\n\n        return dfs(node) if node else None\n", "class Solution:\n    def dummy_def_1(self, grid: List[List[int]]) -> None:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n        q = deque()\n\n        def dummy_def_2(r, c):\n            if (\n                min(r, c) < 0\n                or r == ROWS\n                or c == COLS\n                or (r, c) in visit\n                or grid[r][c] == -1\n            ):\n                return\n            visit.add((r, c))\n            q.append([r, c])\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 0:\n                    q.append([r, c])\n                    visit.add((r, c))\n\n        dist = 0\n        while q:\n            for i in range(len(q)):\n                r, c = q.popleft()\n                grid[r][c] = dist\n                addCell(r + 1, c)\n                addCell(r - 1, c)\n                addCell(r, c + 1)\n                addCell(r, c - 1)\n            dist += 1\n", "class Solution:\n    def dummy_def_1(self, grid: List[List[int]]) -> int:\n        q = collections.deque()\n        fresh = 0\n        time = 0\n\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    fresh += 1\n                if grid[r][c] == 2:\n                    q.append((r, c))\n\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        while fresh > 0 and q:\n            length = len(q)\n            for i in range(length):\n                r, c = q.popleft()\n\n                for dr, dc in directions:\n                    row, col = r + dr, c + dc\n                    if (\n                        row in range(len(grid))\n                        and col in range(len(grid[0]))\n                        and grid[row][col] == 1\n                    ):\n                        grid[row][col] = 2\n                        q.append((row, col))\n                        fresh -= 1\n            time += 1\n        return time if fresh == 0 else -1\n", "class Solution:\n    def dummy_def_1(self, heights: List[List[int]]) -> List[List[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        pac, atl = set(), set()\n\n        def dummy_def_2(r, c, visit, prevHeight):\n            if (\n                (r, c) in visit\n                or r < 0\n                or c < 0\n                or r == ROWS\n                or c == COLS\n                or heights[r][c] < prevHeight\n            ):\n                return\n            visit.add((r, c))\n            dfs(r + 1, c, visit, heights[r][c])\n            dfs(r - 1, c, visit, heights[r][c])\n            dfs(r, c + 1, visit, heights[r][c])\n            dfs(r, c - 1, visit, heights[r][c])\n\n        for c in range(COLS):\n            dfs(0, c, pac, heights[0][c])\n            dfs(ROWS - 1, c, atl, heights[ROWS - 1][c])\n\n        for r in range(ROWS):\n            dfs(r, 0, pac, heights[r][0])\n            dfs(r, COLS - 1, atl, heights[r][COLS - 1])\n\n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                if (r, c) in pac and (r, c) in atl:\n                    res.append([r, c])\n        return res\n", "class Solution:\n    def dummy_def_1(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        preMap = {i: [] for i in range(numCourses)}\n\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n\n        visiting = set()\n\n        def dummy_def_2(crs):\n            if crs in visiting:\n                return False\n            if preMap[crs] == []:\n                return True\n\n            visiting.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visiting.remove(crs)\n            preMap[crs] = []\n            return True\n\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n        return True\n", "class Solution:\n    def dummy_def_1(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        prereq = {c: [] for c in range(numCourses)}\n        for crs, pre in prerequisites:\n            prereq[crs].append(pre)\n\n        output = []\n        visit, cycle = set(), set()\n\n        def dummy_def_2(crs):\n            if crs in cycle:\n                return False\n            if crs in visit:\n                return True\n\n            cycle.add(crs)\n            for pre in prereq[crs]:\n                if dfs(pre) == False:\n                    return False\n            cycle.remove(crs)\n            visit.add(crs)\n            output.append(crs)\n            return True\n\n        for c in range(numCourses):\n            if dfs(c) == False:\n                return []\n        return output\n", "class Solution:\n    def dummy_def_1(self, n: int, edges: List[List[int]]) -> bool:\n        if not n:\n            return True\n        adj = {i: [] for i in range(n)}\n        for n1, n2 in edges:\n            adj[n1].append(n2)\n            adj[n2].append(n1)\n\n        visit = set()\n\n        def dummy_def_2(i: int, prev: int) -> bool:\n            if i in visit:\n                return False\n\n            visit.add(i)\n            for j in adj[i]:\n                if j == prev:\n                    continue\n                if not dfs(j, i):\n                    return False\n            return True\n\n        return dfs(0, -1) and n == len(visit)\n    ", "class Solution:\n    def dummy_def_1(self, times: List[List[int]], n: int, k: int) -> int:\n        edges = collections.defaultdict(list)\n        for u, v, w in times:\n            edges[u].append((v, w))\n\n        minHeap = [(0, k)]\n        visit = set()\n        t = 0\n        while minHeap:\n            w1, n1 = heapq.heappop(minHeap)\n            if n1 in visit:\n                continue\n            visit.add(n1)\n            t = w1\n\n            for n2, w2 in edges[n1]:\n                if n2 not in visit:\n                    heapq.heappush(minHeap, (w1 + w2, n2))\n        return t if len(visit) == n else -1\n", "class Solution:\n    def dummy_def_1(self, points: List[List[int]]) -> int:\n        N = len(points)\n        adj = {i: [] for i in range(N)}\n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i + 1, N):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                adj[i].append([dist, j])\n                adj[j].append([dist, i])\n\n        res = 0\n        visit = set()\n        minH = [[0, 0]]\n        while len(visit) < N:\n            cost, i = heapq.heappop(minH)\n            if i in visit:\n                continue\n            res += cost\n            visit.add(i)\n            for neiCost, nei in adj[i]:\n                if nei not in visit:\n                    heapq.heappush(minH, [neiCost, nei])\n        return res\n", "class Solution:\n    def dummy_def_1(self, nums: List[int]) -> int:\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            temp = max(n + rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n        return rob2\n", "class Solution:\n    def dummy_def_1(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        prices = [float(\"inf\")] * n\n        prices[src] = 0\n\n        for i in range(k + 1):\n            tmpPrices = prices.copy()\n\n            for s, d, p in flights:                  if prices[s] == float(\"inf\"):\n                    continue\n                if prices[s] + p < tmpPrices[d]:\n                    tmpPrices[d] = prices[s] + p\n            prices = tmpPrices\n        return -1 if prices[dst] == float(\"inf\") else prices[dst]\n", "class Solution:\n    \n    def dummy_def_1(self, nums: List[int]) -> int:\n        return max(nums[0], self.helper(nums[1:]), self.helper(nums[:-1]))\n\n    def dummy_def_2(self, nums):\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            newRob = max(rob1 + n, rob2)\n            rob1 = rob2\n            rob2 = newRob\n        return rob2\n", "class Solution:\n    def dummy_def_1(self, m: int, n: int) -> int:\n        row = [1] * n\n\n        for i in range(m - 1):\n            newRow = [1] * n\n            for j in range(n - 2, -1, -1):\n                newRow[j] = newRow[j + 1] + row[j]\n            row = newRow\n        return row[0]\n", "class Solution:\n    def dummy_def_1(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for i in range(len(coins) - 1, -1, -1):\n            nextDP = [0] * (amount + 1)\n            nextDP[0] = 1\n\n            for a in range(1, amount + 1):\n                nextDP[a] = dp[a]\n                if a - coins[i] >= 0:\n                    nextDP[a] += nextDP[a - coins[i]]\n            dp = nextDP\n        return dp[amount]\n", "class Solution:\n    def dummy_def_1(self, word1: str, word2: str) -> int:\n        dp = [[float(\"inf\")] * (len(word2) + 1) for i in range(len(word1) + 1)]\n\n        for j in range(len(word2) + 1):\n            dp[len(word1)][j] = len(word2) - j\n        for i in range(len(word1) + 1):\n            dp[i][len(word2)] = len(word1) - i\n\n        for i in range(len(word1) - 1, -1, -1):\n            for j in range(len(word2) - 1, -1, -1):\n                if word1[i] == word2[j]:\n                    dp[i][j] = dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])\n        return dp[0][0]\n", "class Solution:\n    def dummy_def_1(self, matrix: List[List[int]]) -> None:\n        l, r = 0, len(matrix) - 1\n        while l < r:\n            for i in range(r - l):\n                top, bottom = l, r\n\n                                topLeft = matrix[top][l + i]\n\n                                matrix[top][l + i] = matrix[bottom - i][l]\n\n                                matrix[bottom - i][l] = matrix[bottom][r - i]\n\n                                matrix[bottom][r - i] = matrix[top + i][r]\n\n                                matrix[top + i][r] = topLeft\n            r -= 1\n            l += 1\n", "class Solution:\n    def dummy_def_1(self, S: str) -> List[int]:\n        count = {}\n        res = []\n        i, length = 0, len(S)\n        for j in range(length):\n            c = S[j]\n            count[c] = j\n\n        curLen = 0\n        goal = 0\n        while i < length:\n            c = S[i]\n            goal = max(goal, count[c])\n            curLen += 1\n\n            if goal == i:\n                res.append(curLen)\n                curLen = 0\n            i += 1\n        return res\n", "class Solution:\n    def dummy_def_1(self, s: str) -> bool:\n        leftMin, leftMax = 0, 0\n\n        for c in s:\n            if c == \"(\":\n                leftMin, leftMax = leftMin + 1, leftMax + 1\n            elif c == \")\":\n                leftMin, leftMax = leftMin - 1, leftMax - 1\n            else:\n                leftMin, leftMax = leftMin - 1, leftMax + 1\n            if leftMax < 0:\n                return False\n            if leftMin < 0:\n                leftMin = 0\n        return leftMin == 0\n", "class Solution:\n    def dummy_def_1(self, gas: List[int], cost: List[int]) -> int:\n        if sum(gas) < sum(cost):\n            return -1\n\n        total = 0\n        res = 0\n        for i in range(len(gas)):\n            total += (gas[i] - cost[i])\n\n            if total < 0:\n                total = 0\n                res = i + 1\n        \n        return res\n", "class Solution:\n    def dummy_def_1(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for i in range(len(s1) + 1)]\n        dp[len(s1)][len(s2)] = True\n\n        for i in range(len(s1), -1, -1):\n            for j in range(len(s2), -1, -1):\n                if i < len(s1) and s1[i] == s3[i + j] and dp[i + 1][j]:\n                    dp[i][j] = True\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\n                    dp[i][j] = True\n        return dp[0][0]\n", "class Solution:\n    def dummy_def_1(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        visit = set()\n        minH = [[grid[0][0], 0, 0]]          directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        visit.add((0, 0))\n        while minH:\n            t, r, c = heapq.heappop(minH)\n            if r == N - 1 and c == N - 1:\n                return t\n            for dr, dc in directions:\n                neiR, neiC = r + dr, c + dc\n                if (\n                    neiR < 0\n                    or neiC < 0\n                    or neiR == N\n                    or neiC == N\n                    or (neiR, neiC) in visit\n                ):\n                    continue\n                visit.add((neiR, neiC))\n                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])\n", "class Solution:\n    def dummy_def_1(self, words: List[str]) -> str:\n        adj = {char: set() for word in words for char in word}\n\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            minLen = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n                return \"\"\n            for j in range(minLen):\n                if w1[j] != w2[j]:\n                    adj[w1[j]].add(w2[j])\n                    break\n\n        visited = {}          res = []\n\n        def dummy_def_2(char):\n            if char in visited:\n                return visited[char]\n\n            visited[char] = True\n\n            for neighChar in adj[char]:\n                if dfs(neighChar):\n                    return True\n\n            visited[char] = False\n            res.append(char)\n\n        for char in adj:\n            if dfs(char):\n                return \"\"\n\n        res.reverse()\n        return \"\".join(res)\n", "class Solution:\n    def dummy_def_1(self, nums: List[int]) -> int:\n        cache = {}\n        nums = [1] + nums + [1]\n\n        for offset in range(2, len(nums)):\n            for left in range(len(nums) - offset):\n                right = left + offset\n                for pivot in range(left + 1, right):\n                    coins = nums[left] * nums[pivot] * nums[right]\n                    coins += cache.get((left, pivot), 0) + cache.get((pivot, right), 0)\n                    cache[(left, right)] = max(coins, cache.get((left, right), 0))\n        return cache.get((0, len(nums) - 1), 0)\n", "class Solution:\n    def dummy_def_1(self, s: str, p: str) -> bool:\n        cache = [[False] * (len(p) + 1) for i in range(len(s) + 1)]\n        cache[len(s)][len(p)] = True\n\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n\n                if (j + 1) < len(p) and p[j + 1] == \"*\":\n                    cache[i][j] = cache[i][j + 2]\n                    if match:\n                        cache[i][j] = cache[i + 1][j] or cache[i][j]\n                elif match:\n                    cache[i][j] = cache[i + 1][j + 1]\n\n        return cache[0][0]\n", "class Trie:\n\n    def dummy_def_1(self):\n        self.children = [None] * 26\n        self.is_word = False\n\n    def dummy_def_2(self, word):\n        current = self\n        i = len(word) - 1\n        while i >= 0:\n            index = ord(word[i]) - 97\n            if not current.children[index]:\n                current.children[index] = Trie()\n            current = current.children[index]\n            i -= 1\n        current.is_word = True\n\n\nclass StreamChecker:\n\n    def dummy_def_3(self, words: List[str]):\n        self.stack = []\n        self.words = Trie()\n        for word in words:\n            self.words.addWord(word)\n\n    def dummy_def_4(self, letter: str) -> bool:\n        self.stack.append(letter)\n        current = self.words\n        pop = len(self.stack) - 1\n        while pop >= 0:    \n            index = ord(self.stack[pop]) - 97\n            if current.is_word:\n                return True\n            if not current.children[index]:\n                return False\n            current = current.children[index]\n            pop -= 1\n        return current.is_word\n\nobj = StreamChecker(words)\nparam_1 = obj.query(letter)", "class Solution:\n    def dummy_def_1(self, prices: List[int]) -> int:\n        transaction_one = float(inf)\n        transaction_two = float(inf)\n        current_profit = 0\n        total_profit = 0\n        for price in prices:\n            transaction_one = min(transaction_one, price)\n            current_profit = max(current_profit, price - transaction_one)\n            transaction_two = min(transaction_two, price - current_profit)\n            total_profit = max(total_profit, price - transaction_two)\n        return total_profit", "class Solution:\n    def dummy_def_1(self, arr: List[int]) -> int:\n        indices = {}\n        visited = set()\n        queue = [[0, 0]]         length = len(arr)\n        for ind, num in enumerate(arr):\n            if num not in indices:\n                indices[num] = []\n            indices[num].append(ind)\n        while queue:\n            index, steps = queue.pop(0)\n            if index == length - 1:\n                break\n            if indices[arr[index]]:\n                for i in indices[arr[index]]:\n                    if i not in visited:\n                        visited.add(i)\n                        queue.append([i, steps+1])\n                indices[arr[index]] = []\n            if index - 1 > 0 and index - 1 not in visited:\n                visited.add(index-1)\n                queue.append([index-1, steps+1])\n            if index + 1 not in visited:\n                visited.add(index+1)\n                queue.append([index+1, steps+1])\n        return steps", "class Solution:\n    def dummy_def_1(self, target: int, mountain_arr: 'MountainArray') -> int:\n        peak = self.peakBinarySearch(mountain_arr)\n        result = self.targetBinarySearchLeft(mountain_arr, target, peak)\n        if -1 == result:\n            result = self.targetBinarySearchRight(mountain_arr, target, peak)\n        return result\n        \n    def dummy_def_2(self, mountain_arr, target, peak):\n        \n        left = 0\n        right = peak\n        while left <= right:\n            middle = (left + right) // 2\n            if mountain_arr.get(middle) == target:\n                return middle\n            if mountain_arr.get(middle) > target:\n                right = middle - 1\n            else:\n                left = middle + 1\n        return -1\n    \n    def dummy_def_3(self, mountain_arr, target, peak):\n        \n        left = peak\n        right = mountain_arr.length() - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if mountain_arr.get(middle) == target:\n                return middle\n            if mountain_arr.get(middle) < target:\n                right = middle - 1\n            else:\n                left = middle + 1\n        return -1\n    \n    def dummy_def_4(self, mountain_arr):\n        \n        left = 1\n        right = mountain_arr.length() - 1\n        while left <= right:\n            middle = (left + right) // 2\n            mid_ele = mountain_arr.get(middle)\n            left_ele = mountain_arr.get(middle-1)\n            right_ele = mountain_arr.get(middle+1)\n            if left_ele < mid_ele > right_ele:\n                return middle\n            if left_ele > mid_ele > right_ele:\n                right = middle - 1\n            else:\n                left = middle + 1", "class Solution:\n    def dummy_def_1(self, root: TreeNode) -> List[int]:\n        postorder = []\n        self.traverse(root, postorder)\n        return postorder\n\n    def dummy_def_2(self, root, postorder):\n        if not root:\n            return 0\n        self.traverse(root.left, postorder)\n        self.traverse(root.right, postorder)\n        postorder.append(root.val)", "class Solution:\n\n    def dummy_def_1(self, grid: List[List[int]]) -> int:\n        self.grid = grid\n        self.rows = len(grid)\n        self.cols = len(grid[0]) \n        return self.dfs(0, 0, self.cols-1)\n\n    @lru_cache(None)\n    def dummy_def_2(self, row, x, y):\n        if x < 0 or x >= self.cols or y < 0 or y >= self.cols:\n            return 0\n        result = 0\n        result += self.grid[row][x]\n        if x != y:\n            result += self.grid[row][y]\n        if row < self.rows - 1:\n            vals = []\n            for i in [x-1, x, x+1]:\n                for j in [y-1, y, y+1]:\n                    vals.append(self.dfs(row+1, i, j))\n            result += max(vals)\n        return result", "class Solution:\n    def dummy_def_1(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] < nums[0]:\n                return nums[i]\n        return nums[0] ", "class Solution:\n    def dummy_def_1(self, nums: List[int]) -> int:\n        nums.sort()\n        difference = 0\n        for i in range(1,len(nums)):\n            difference = max(difference, abs(nums[i]-nums[i-1]))\n        return difference", "class Solution:\n    def dummy_def_1(self, lists: List[ListNode]) -> ListNode:\n        head = ListNode()\n        node = head\n        nodes = []\n        for l_list in lists:\n            while l_list:\n                nodes.append(l_list.val)\n                l_list = l_list.next\n        for val in sorted(nodes):\n            node.next = ListNode(val)\n            node = node.next\n        return head.next", "class Solution:\n    def dummy_def_1(self, head: ListNode, k: int) -> ListNode:\n        stack = []\n        new_head = ListNode()\n        node = new_head\n        i = 0\n        while head:\n            while i != k and head:\n                i += 1\n                stack.append(head)\n                head = head.next\n            while i == k and stack:\n                node.next = stack.pop()\n                node = node.next\n                node.next = None\n            i = 0\n        if stack:\n            node.next = stack.pop(0)\n        return new_head.next", "class MedianFinder:\n\n    def dummy_def_1(self):\n        \n        self.array = []\n        self.length = 0\n\n    def dummy_def_2(self, num: int) -> None:\n        self.length += 1\n        if not self.array:\n            self.array.append(num)\n        else:\n            self.binarySearch(num)\n\n    def dummy_def_3(self, num):\n        l = 0\n        r = len(self.array) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if  self.array[m-1] <= num <= self.array[m]:\n                return self.array.insert(m, num)\n            elif num > self.array[m]:\n                l = m + 1\n            else:\n                r = m - 1\n        return self.array.insert(l, num)\n\n    def dummy_def_4(self) -> float:\n        if self.length % 2:\n            return self.array[self.length//2]\n        else:\n            return (self.array[-1+self.length//2] + self.array[self.length//2]) / 2\n\nobj = MedianFinder()\nobj.addNum(num)\nparam_2 = obj.findMedian()", "from typing import List\n\nclass Solution:\n    def dummy_def_1(self, s: str, wordDict: List[str]) -> bool:\n        dp = [0] * len(s)\n        for word in wordDict:\n            if word == s[:len(word)]:\n                dp[len(word) - 1] = 1\n        for i in range(0, len(dp)):\n            if dp[i] == 1:\n                for word in wordDict:\n                    if word == s[i + 1:i + len(word) + 1]:\n                        dp[i + len(word)] = 1\n        print(dp)\n        if dp[-1] == 1:\n            return True\n        return False", "import math\n\n\nclass TreeNode:\n    def dummy_def_1(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def dummy_def_2(self, root: TreeNode) -> bool:\n        def dummy_def_3(root, less, more):\n            if not root:\n                return True\n            if not less<root.val<more:\n                return False\n            else:\n                return solve(root.left, less, root.val) and solve(root.right, root.val, more)\n        return solve(root, -math.inf, math.inf)", "class Solution:\n    def dummy_def_1(self, s: str) -> bool:\n        pair = {']':'[', '}':'{', ')':'('}\n        curr = []\n        for char in s:\n            if char in pair:\n                if len(curr) ==0 or curr.pop()!= pair[char]:\n                    return False\n            else:\n                curr.append(char)\n        if len(curr)!=0:\n            return False\n        return True", "class Solution:\n    def dummy_def_1(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n        while l < r:\n            while not s[l].isalnum() and l < r:\n                l += 1\n            while not s[r].isalnum() and l < r:\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l += 1\n            r -= 1\n        return True", "class Solution:\n    def dummy_def_1(self, s: str, t: str) -> bool:\n        chars={}\n        for char in s:\n            if char in chars:\n                chars[char]+=1\n            else:\n                chars[char]=1\n        for char in t:\n            if char not in chars:\n                return False\n            if char in chars:\n                chars[char]-=1\n                if chars[char]==0:\n                    del chars[char]\n        if chars:\n            return False\n        return True", "from functools import lru_cache\nclass Solution:\n    def dummy_def_1(self, m: int, n: int) -> int:\n        @lru_cache(maxsize=None)\n        def dummy_def_2(m, n):\n            if m < 1 or n < 1:\n                return 0\n            if m == 1 or n == 1:\n                return 1\n            return dp(m - 1, n) + dp(m, n - 1)\n        return dp(m, n)", "from typing import List\n\n\nclass Solution:\n    def dummy_def_1(self, nums: List[int], target: int) -> List[int]:\n        mp = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in mp:\n                return [mp[complement],i]\n            else:\n                mp[num]=i", "import heapq\nfrom typing import List\n\n\nclass Solution:\n    def dummy_def_1(self, nums: List[int], k: int) -> List[int]:\n        count={}\n        for num in nums:\n            if num in count:\n                count[num]+=1\n            else:\n                count[num]=1\n        ans = heapq.nlargest(k, count.keys(), key=count.get)\n        return ans", "from typing import List\n\n\nclass Solution:\n    def dummy_def_1(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans = []\n        for i, num in enumerate(nums):\n            if i >= 1:\n                if nums[i-1]==nums[i]:\n                    continue\n            l,r = i+1, len(nums)-1\n            while l < r:\n                total = num + nums[l]+nums[r]\n                if total > 0:\n                    r-=1\n                elif total < 0:\n                    l+=1\n                else:\n                    ans.append([num, nums[l], nums[r]])\n                    l+=1\n                    while l < r and nums[l-1]==nums[l]:\n                        l+=1\n        return ans", "class TreeNode:\n    def dummy_def_1(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def dummy_def_2(self, r, sr):\n        if not r and not sr:\n            return True\n        elif not r or not sr:\n            return False\n        return r.val == sr.val and self.isSameTree(r.left, sr.left) and self.isSameTree(r.right, sr.right)\n\n    def dummy_def_3(self, root: TreeNode, subRoot: TreeNode) -> bool:\n        if self.isSameTree(root, subRoot):\n            return True\n        if not root:\n            return False\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)", "from typing import List\n\n\nclass Solution:\n    def dummy_def_1(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target <= nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] <= target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return -1"]